// ============================================================
// åœ°æš–ç»¼åˆæ§åˆ¶ä¸»ä»£ç  v25.5 (FINAL + æ³¨é‡Šè¡¥å…¨ç‰ˆ + é”…ç‚‰çŠ¶æ€status)
// timer = 5ç§’
// Outputs = 7
//
// 1) ç›®æ ‡æ¸©åº¦æ˜¾ç¤ºï¼ˆæ•´æ•°ï¼Œä»…å‰ç«¯æ˜¾ç¤ºï¼‰ msg.payload="44"
// 2) é˜€é—¨å¼€åº¦ï¼ˆ1~4095ï¼‰ msg.payload=1920
// 3) WSåŒæ­¥/æ¢å¤ï¼šæ­£å¸¸=JSONå­—ç¬¦ä¸²å¿«ç…§ï¼›æ— æœ¬åœ°æ•°æ®=å…ˆå‘"recover"(æœ€å¤š2æ¬¡)
// 4) é”…ç‚‰åœ°æš–å‘½ä»¤ï¼šmsg.payload="heat"/"off"ï¼ˆç”¨äºåå¤ä¸‹å‘ç»™é”…ç‚‰ï¼‰
// 5) å¼ºåˆ¶å¼€å…³å›å¼¹ï¼šenforceæŒ‰ä¸‹åè‡ªåŠ¨å…³ï¼ˆç»™ HA action èŠ‚ç‚¹ï¼‰
// 6) ç‰©ç†ä¾›æ°´æ¸©æ§å™¨æ¨¡å¼ï¼šmsg.topic + msg.payload(heat/off)
// 7) ä¸¥é‡ç³»ç»Ÿæ•…éšœæŠ¥è­¦ï¼ˆå¾®ä¿¡æ¨é€ï¼‰ï¼šmsg.title(ç®€è¦) + msg.payload(è¯¦ç»†å¤šè¡Œ)
//
// ä¼ æ„Ÿå™¨åˆ†è¾¨ç‡ï¼ˆå·²ç¡®è®¤ï¼‰
// - floorheating_mixedwater_temperature_state : 0.1â„ƒï¼ˆæ··æ°´ï¼Œæ§åˆ¶ä¸»åé¦ˆï¼‰
// - floorheating_watertank                   : 0.1â„ƒï¼ˆæ°´ç®±æ¸©åº¦ï¼‰
// - outside_temperature_state                : 0.1â„ƒï¼ˆæˆ·å¤–æ¸©åº¦ï¼‰
// - floorheating_outputwater_temperature_state: 1â„ƒï¼ˆåœ°æš–å‡ºæ°´ï¼‰
// - floorheating_returnwater_temperature_state: 1â„ƒï¼ˆåœ°æš–å›æ°´ï¼‰
// - floorheating_waterflow_state             : 0.001 mÂ³/hï¼ˆåœ°æš–æ€»æµé‡ï¼‰
// - æˆ¿é—´ current/target                       : 1â„ƒï¼ˆæ•´åº¦ï¼‰ï¼›æˆ¿é—´æ¨¡å¼æ—  autoï¼Œä»… heat/off
//
// é˜€é—¨ï¼š40~50ç§’å…¨è¡Œç¨‹ï¼›ç³»ç»Ÿå…³é—­æ—¶è¾“å‡º 4095ï¼ˆå¿«å¼€+æ’æ°”ç­–ç•¥ï¼‰
// ============================================================


// ------------------------------------------------------------------------
// ã€æŠ¥è­¦é…ç½®ï¼ˆå¾®ä¿¡æ¨é€ï¼‰ã€‘
// - msg.title  = â€œæ•…éšœç®€è¦æè¿°â€
// - msg.payload= â€œè¯¦ç»†å†…å®¹ï¼ˆå¤šè¡Œï¼‰â€
// - SAME_CODE_DEDUP_MSï¼šåŒä¸€ç±»æŠ¥è­¦åœ¨å¤šå°‘æ—¶é—´å†…åªå‘ä¸€æ¬¡ï¼ˆé˜²åˆ·å±ï¼‰
// ------------------------------------------------------------------------
const ALARM_CONFIG = {
    HOST: "",                                // ç•™ç©ºï¼šä¸æ˜¾ç¤ºâ€œä½ç½®ï¼šxxxâ€
    SAME_CODE_DEDUP_MS: 3 * 60 * 60 * 1000   // 3å°æ—¶å†…ç›¸åŒæŠ¥è­¦ code åªå‘ä¸€æ¬¡
};


// ------------------------------------------------------------------------
// ã€WS Recoverï¼ˆå¤ç”¨ Output3ï¼‰ã€‘
// èƒŒæ™¯ï¼šNode-RED é‡å¯/éƒ¨ç½²åï¼Œæœ¬æœº flow çš„ state ä¼šä¸¢å¤±ï¼›
// - å¦‚æœæœ¬æœº STORAGE_KEY æ²¡æ•°æ®ï¼šOutput3 å…ˆå‘ "recover" è¯·æ±‚ï¼ˆæœ€å¤š2æ¬¡ï¼‰
// - ä¸‹ä¸€è½® timer å†è¯»å– STORAGE_KEYï¼ˆç”±â€œæ¢å¤å†™å›èŠ‚ç‚¹â€å†™å…¥ï¼‰
// - READY_FLAG_KEY ç”±â€œæ¢å¤å†™å›èŠ‚ç‚¹â€ç½® trueï¼Œè¡¨ç¤ºæ¢å¤å®Œæˆ
// ------------------------------------------------------------------------
const RECOVER_CONFIG = {
    ENABLED: true,
    STORAGE_KEY: "fh_v24_final",
    READY_FLAG_KEY: "fh_remote_state_ready",
    CTX_KEY: "fh_recover_ctrl",
    APPLIED_KEY: "fh_recover_applied",
    MAX_ATTEMPTS: 2
};


// ------------------------------------------------------------------------
// ã€å¯åœè§„åˆ™ã€‘
// - æ‰“å¼€ï¼šä»»æ„åˆ†æ°´å™¨å¼€ && æˆ·å¤–<16
// - å…³é—­ï¼šæ‰€æœ‰åˆ†æ°´å™¨å…³ && æˆ·å¤–>16
// - åº”æ€¥ï¼šå¼ºåˆ¶å¼€å…³æŒ‰ä¸‹ && ä»»æ„åˆ†æ°´å™¨å¼€ => å¼€ä¸€æ¬¡ï¼Œå¹¶è‡ªåŠ¨å›å¼¹å…³æ‰
// ------------------------------------------------------------------------
const CONTROL_RULE = {
    OUTDOOR_THRESHOLD_C: 16,
    ENFORCE_FLOW_KEY: "floorheating_state_enforce"
};


// ------------------------------------------------------------------------
// ã€ç³»ç»Ÿçº§å¥åº·ç›‘æ§ã€‘
// åªç›‘æ§â€œåœ°æš–ç³»ç»Ÿæœ¬ä½“å¼‚å¸¸â€ï¼Œé¿å…å…³æœºæµé‡å½’é›¶è¯¯åˆ¤ã€‚
// ------------------------------------------------------------------------
const HEALTH = {
    STARTUP_GRACE_S: 180,
    DEMAND_ERR_C: 1.5,

    FLOW_LOW_M3H: 0.05,
    FLOW_OK_M3H: 0.10,
    FLOW_STRONG_M3H: 0.15,

    FLOW0_HOLD_S: 120,
    MIX_STALE_HOLD_S: 600,
    NO_RISE_HOLD_S: 600,
    NO_RISE_DELTA_C: 0.2,

    VALVE_OPEN_SP: 2600,
    TANK_HOT_MARGIN_C: 2.0
};


// ------------------------------------------------------------------------
// ã€ç³»ç»Ÿæ ¸å¿ƒå‚æ•°ã€‘
// ç›®æ ‡æ¸©åº¦å¹³æ»‘ / åŠŸç‡ / Î”T ä¼°ç®—èŒƒå›´ç­‰
// ------------------------------------------------------------------------
const SYSTEM = {
    STORAGE_KEY: RECOVER_CONFIG.STORAGE_KEY,

    MIN_TEMP: 30,
    MAX_TEMP: 61,

    TICK_S: 5,
    TARGET_TAU_S: 20,
    TARGET_MAX_STEP_PER_TICK_C: 0.35,

    HEAT: {
        NOFLOW_M3H: 0.05,
        DT_MIN_C: 3.5,
        DT_MAX_C: 12.0,
        DT_DEADBAND_C: 0.3,
        P_EMA_TAU_S: 150,
        OBS_MAX_KW: 30,
        TARGET_MAX_KW: 20
    },

    ROOM: {
        KW_PER_INDEX: 0.65,
        MAX_UNDERHEAT_DURATION: 900,
        COMP_INC: 1.0,
        MAX_COMP: 5.0
    },

    COMFORT: {
        E_UP_C: 1.0,
        E_DOWN_C: 0.0,
        UP_HOLD_S: 10 * 60,
        DOWN_HOLD_S: 60 * 60,
        KW_PER_C: 0.9,
        STEP_KW: 1.0
    },

    OUTDOOR_RESET: { REF_C: 16, SLOPE: 0.30 },
    OUTDOOR_ADJ: { REF_C: 5, SLOPE: 0.25 },
    SUN: { REF_LUX: 1000, SLOPE: -1.0 / 50000, MAX: -2.0 },

    TANK: {
        HEAT_RATE: 0.18,
        BUFFER_L: 80,
        SPECIFIC_HEAT: 4.186,
        DENSITY: 1000,
        LOSS_RATE: 30 / (6 * 3600)
    },

    KEY: {
        OUTDOOR: "outside_temperature_state",
        TANK: "floorheating_watertank",
        SUN: "floorheating_sunlight",
        MIXED: "floorheating_mixedwater_temperature_state",
        RETURN: "floorheating_returnwater_temperature_state",
        OUTPUT: "floorheating_outputwater_temperature_state",
        FLOW: "floorheating_waterflow_state",

        BOILER_BURNING: "boiler_burning_status",
        BOILER_FH: "boiler_floorheating_status",
        BOILER_HW: "boiler_hot_water_status"
    }
};


// ========================= å·¥å…·å‡½æ•° =========================
function clamp(v, min, max) { return isNaN(v) ? min : Math.min(Math.max(v, min), max); }
function f01(v) { return Math.min(Math.max(v, 0), 1); }
function isOnLike(v) { return ["on","true","1","heat","enable","opened"].includes(String(v).toLowerCase().trim()); }
function fmt1(v) { return Number.isFinite(v) ? Number(v).toFixed(1) : "-"; }
function fmt0(v) { return Number.isFinite(v) ? String(Math.round(Number(v))) : "-"; }
function nowMs() { return Date.now(); }

// é”…ç‚‰çŠ¶æ€çŸ­æ ‡è®°ï¼ˆstatusç”¨ï¼Œå°½é‡çŸ­ï¼‰
// - "--"   ä¸ç‡ƒçƒ§/æœªçŸ¥
// - "B+FH" æ­£åœ¨ç‡ƒçƒ§ï¼Œä¸”åœ¨åœ°æš–/ç¼“å†²åŠ çƒ­ï¼ˆbuffer_heatï¼‰
// - "B+HW" æ­£åœ¨ç‡ƒçƒ§ï¼Œä¸”åœ¨ç”Ÿæ´»çƒ­æ°´ï¼ˆdomesticï¼‰
// - "B+"   ä»…ç‡ƒçƒ§ä½†æ¨¡å¼æœªçŸ¥
function boilerTagFromState(state) {
    let tag = "--";
    if (state && state.sys && state.sys.boilerBurning) {
        if (state.sys.boilerMode === "buffer_heat") tag = "B+FH";
        else if (state.sys.boilerMode === "domestic") tag = "B+HW";
        else tag = "B+";
    }
    return tag;
}

function alarmDedup(code) {
    const now = nowMs();
    const map = context.get("fh_alarm_last_by_code") || {};
    const last = Number(map[code]) || 0;
    if (now - last < ALARM_CONFIG.SAME_CODE_DEDUP_MS) return false;
    map[code] = now;
    context.set("fh_alarm_last_by_code", map);
    return true;
}

// ç”Ÿæˆï¼šmsg.title=ç®€è¦ï¼›msg.payload=è¯¦ç»†ï¼ˆå¤šè¡Œé€šä¿—ï¼‰
function buildAlarmMsg(code, title, lines) {
    if (!alarmDedup(code)) return null;

    const payloadLines = [];
    if (ALARM_CONFIG.HOST && String(ALARM_CONFIG.HOST).trim()) payloadLines.push(`ä½ç½®ï¼š${ALARM_CONFIG.HOST}`);
    for (const l of (lines || [])) if (l && String(l).trim()) payloadLines.push(String(l));

    return { title, payload: payloadLines.join("\n"), code };
}


// ========================= é»˜è®¤ state + åˆå¹¶ =========================
function defaultState() {
    return {
        sys: { enabled: false, boilerMode: "init", boilerBurning: false, boilerFloorHeating: false },
        ctrl: { outputRaw: 38.0, lastTargetTs: 0, lastUpdate: nowMs() },
        thermal: { watertank: 55.0, outdoor: 10.0 },
        sensors: {
            sunlight: 500,
            returnWaterTemp: 30,
            mixedWaterTemp: 35.0,
            outputWaterTemp: 35,
            waterFlowM3h: 0.0,
            deltaT_supply_return: 0.0,
            heatPowerObsKw: 0.0,
            heatPowerEmaKw: 0.0,
            heatPowerTargetKw: 0.0,
            targetDeltaT: 0.0,
            targetTempCandidate: 0.0
        },
        comfort: { lastTs: nowMs(), emax: 0, upHoldS: 0, downHoldS: 0 },
        roomStates: {},
        valveLast: {
            set_point: 4095,
            ratio_ema: null,
            sp_last_ts: 0,
            unreachable: false,

            // å…¼å®¹å­—æ®µï¼ˆä¸åˆ ï¼‰
            load_int: 0,
            load_last_ts: 0,
            load_bias_level: 0,
            load_err_kw: 0
        }
    };
}

function mergeState(stored) {
    const d = defaultState();
    const s = (stored && typeof stored === "object") ? stored : {};
    const out = {
        ...d,
        ...s,
        sys: { ...d.sys, ...(s.sys || {}) },
        ctrl: { ...d.ctrl, ...(s.ctrl || {}) },
        thermal: { ...d.thermal, ...(s.thermal || {}) },
        sensors: { ...d.sensors, ...(s.sensors || {}) },
        comfort: { ...d.comfort, ...(s.comfort || {}) },
        roomStates: { ...d.roomStates, ...(s.roomStates || {}) },
        valveLast: { ...d.valveLast, ...(s.valveLast || {}) }
    };

    out.ctrl.outputRaw = Number(out.ctrl.outputRaw) || d.ctrl.outputRaw;
    out.thermal.watertank = parseFloat(Number(out.thermal.watertank).toFixed(1));
    out.thermal.outdoor   = parseFloat(Number(out.thermal.outdoor).toFixed(1));
    out.sensors.mixedWaterTemp = parseFloat(Number(out.sensors.mixedWaterTemp).toFixed(1));
    out.sensors.waterFlowM3h = Number(out.sensors.waterFlowM3h) || 0;

    return out;
}


// ========================= Recoverï¼ˆOutput3å¤ç”¨ï¼‰ =========================
function initRecoverCtrl(hasStored) {
    if (!RECOVER_CONFIG.ENABLED) return;

    const ready = (flow.get(RECOVER_CONFIG.READY_FLAG_KEY) === true);
    let rc = context.get(RECOVER_CONFIG.CTX_KEY) || { need: false, attempts: 0, done: false };

    if (ready) {
        rc.need = false; rc.done = true;
        context.set(RECOVER_CONFIG.CTX_KEY, rc);
        return;
    }

    if (!hasStored && !rc.done) {
        rc.need = true;
        rc.attempts = Number(rc.attempts) || 0;
        context.set(RECOVER_CONFIG.CTX_KEY, rc);

        flow.set(RECOVER_CONFIG.READY_FLAG_KEY, false);
        context.set(RECOVER_CONFIG.APPLIED_KEY, false);
    }
}

function output3Payload(trigger, stateObj) {
    if (trigger !== "timer") return { msg: null, tag: "" };

    if (!RECOVER_CONFIG.ENABLED) {
        return { msg: { payload: JSON.stringify(stateObj), topic: "fh_sync" }, tag: "" };
    }

    const ready = (flow.get(RECOVER_CONFIG.READY_FLAG_KEY) === true);
    let rc = context.get(RECOVER_CONFIG.CTX_KEY) || { need: false, attempts: 0, done: false };

    if (ready) {
        rc.need = false; rc.done = true;
        context.set(RECOVER_CONFIG.CTX_KEY, rc);
        return { msg: { payload: JSON.stringify(stateObj), topic: "fh_sync" }, tag: "" };
    }

    if (rc.need) {
        if ((rc.attempts || 0) < RECOVER_CONFIG.MAX_ATTEMPTS) {
            rc.attempts = (rc.attempts || 0) + 1;
            context.set(RECOVER_CONFIG.CTX_KEY, rc);
            return { msg: { payload: "recover", topic: "fh_sync" }, tag: `ğŸ”„${rc.attempts}/${RECOVER_CONFIG.MAX_ATTEMPTS}` };
        }
        rc.need = false;
        context.set(RECOVER_CONFIG.CTX_KEY, rc);
    }

    return { msg: { payload: JSON.stringify(stateObj), topic: "fh_sync" }, tag: "" };
}


// ========================= æˆ¿é—´æ¨¡å¼ï¼ˆåˆ†æ°´å™¨å¼€å…³ï¼‰ =========================
function readRoomModes() {
    const ids = ["can_ting", "ke_ting", "shu_fang", "zhu_wo", "wo_shi_1", "wo_shi_2", "wo_shi_3"];

    const raw = {};
    let anyOpen = false;
    let allClosed = true;

    for (const id of ids) {
        const v = flow.get(`floorheating_${id}_di_nuan_state`);
        raw[id] = v;

        const on = (String(v).toLowerCase().trim() === "heat") || isOnLike(v);
        if (on) anyOpen = true;
        if (on) allClosed = false;
    }

    return { raw, anyOpen, allClosed };
}

function roomCur(id) { return clamp(Number(flow.get(`floorheating_${id}_di_nuan_current_temp`)) || 20, 10, 40); }
function roomTgt(id) { return clamp(Number(flow.get(`floorheating_${id}_di_nuan_target_temp`)) || 22, 16, 35); }


// ========================= ä¾›æ°´æ¨¡å¼è¾“å‡ºï¼ˆOutput6ï¼‰ =========================
function buildSupplyMode(room, forceOff) {
    if (forceOff) {
        flow.set("floor_heating_supply_on", false);
        return { topic: "climate/dinuan/gongshui/mode/set", payload: "off", state: "forced_off" };
    }

    let anyHeat = false;
    let allOff = true;

    for (const id of Object.keys(room.raw)) {
        const s = (room.raw[id] === undefined || room.raw[id] === null) ? "" : String(room.raw[id]).toLowerCase().trim();
        if (s === "heat") anyHeat = true;
        if (s !== "off") allOff = false;
    }

    if (anyHeat) {
        flow.set("floor_heating_supply_on", true);
        return { topic: "climate/dinuan/gongshui/mode/set", payload: "heat", state: "kai" };
    }
    if (allOff) {
        flow.set("floor_heating_supply_on", false);
        return { topic: "climate/dinuan/gongshui/mode/set", payload: "off", state: "guan" };
    }

    return null;
}


// ========================= ä¼ æ„Ÿå™¨æ›´æ–° =========================
function updateSensors(state) {
    const b1 = flow.get(SYSTEM.KEY.BOILER_BURNING);
    const b2 = flow.get(SYSTEM.KEY.BOILER_FH);
    state.sys.boilerBurning = (b1 !== undefined) ? isOnLike(b1) : false;
    state.sys.boilerFloorHeating = (b2 !== undefined) ? isOnLike(b2) : false;

    const out = parseFloat(flow.get(SYSTEM.KEY.OUTDOOR));
    if (Number.isFinite(out)) state.thermal.outdoor = parseFloat(clamp(out, -30, 50).toFixed(1));

    const tank = parseFloat(flow.get(SYSTEM.KEY.TANK));
    if (Number.isFinite(tank)) state.thermal.watertank = parseFloat(clamp(tank, 10, 80).toFixed(1));

    const sun = parseFloat(flow.get(SYSTEM.KEY.SUN));
    if (Number.isFinite(sun)) state.sensors.sunlight = sun;

    const Tr = parseFloat(flow.get(SYSTEM.KEY.RETURN));
    if (Number.isFinite(Tr)) state.sensors.returnWaterTemp = Tr;

    const Tm = parseFloat(flow.get(SYSTEM.KEY.MIXED));
    if (Number.isFinite(Tm)) state.sensors.mixedWaterTemp = parseFloat(Tm.toFixed(1));

    const To = parseFloat(flow.get(SYSTEM.KEY.OUTPUT));
    if (Number.isFinite(To)) state.sensors.outputWaterTemp = To;

    const Q = parseFloat(flow.get(SYSTEM.KEY.FLOW));
    state.sensors.waterFlowM3h = Number.isFinite(Q) ? clamp(Q, 0, 5.0) : 0.0;

    if (state.sys.boilerBurning) state.sys.boilerMode = state.sys.boilerFloorHeating ? "buffer_heat" : "domestic";
    else state.sys.boilerMode = "cooling";
}


// ========================= çƒ­è´Ÿè·ï¼ˆåŠŸç‡è§‚æµ‹ EMAï¼‰ =========================
function updateHeatPower(state, intervalSec) {
    const Ts = (Number.isFinite(state.sensors.outputWaterTemp) && state.sensors.outputWaterTemp !== 0)
        ? Number(state.sensors.outputWaterTemp)
        : Number(state.sensors.mixedWaterTemp);

    const Tr = Number(state.sensors.returnWaterTemp);
    const Q  = Number(state.sensors.waterFlowM3h) || 0;

    let dT = (Number.isFinite(Ts) && Number.isFinite(Tr)) ? (Ts - Tr) : 0;
    if (!Number.isFinite(dT) || dT <= 0) dT = 0;
    if (dT > 0 && dT < SYSTEM.HEAT.DT_DEADBAND_C) dT = 0;

    state.sensors.deltaT_supply_return = dT;

    let Pobs = 0;
    if (Q > 0 && dT > 0) Pobs = 1.163 * Q * dT;
    Pobs = clamp(Pobs, 0, SYSTEM.HEAT.OBS_MAX_KW);
    state.sensors.heatPowerObsKw = Pobs;

    const tau = SYSTEM.HEAT.P_EMA_TAU_S;
    const alpha = intervalSec / (tau + intervalSec);
    const prev = Number(state.sensors.heatPowerEmaKw) || 0;
    state.sensors.heatPowerEmaKw = prev + alpha * (Pobs - prev);

    return (state.sensors.heatPowerEmaKw * 1000) * intervalSec;
}


// ========================= ç›®æ ‡åŠŸç‡ï¼ˆæˆ¿é—´èˆ’é€‚ï¼‰ =========================
function updateComfort(state, now, anyOpen, room) {
    const c = state.comfort || { lastTs: now, emax: 0, upHoldS: 0, downHoldS: 0 };
    const dt = Math.max(1, (now - (Number(c.lastTs) || now)) / 1000);
    c.lastTs = now;

    if (!anyOpen) {
        c.emax = 0; c.upHoldS = 0; c.downHoldS = 0;
        state.comfort = c;
        return c;
    }

    let emax = 0;
    for (const id of Object.keys(room.raw)) {
        const on = (String(room.raw[id]).toLowerCase().trim() === "heat") || isOnLike(room.raw[id]);
        if (!on) continue;
        emax = Math.max(emax, (roomTgt(id) - roomCur(id)));
    }
    c.emax = emax;

    if (emax >= SYSTEM.COMFORT.E_UP_C) c.upHoldS += dt; else c.upHoldS = 0;
    if (emax <= SYSTEM.COMFORT.E_DOWN_C) c.downHoldS += dt; else c.downHoldS = 0;

    state.comfort = c;
    return c;
}

function demandIndex(state, now, room) {
    let idx = 0;

    for (const id of Object.keys(room.raw)) {
        const on = (String(room.raw[id]).toLowerCase().trim() === "heat") || isOnLike(room.raw[id]);
        if (!on) continue;

        if (!state.roomStates[id]) state.roomStates[id] = { under: 0, last: now, comp: 0 };
        const rs = state.roomStates[id];

        const dt = Math.max(1, (now - (Number(rs.last) || now)) / 1000);
        rs.last = now;

        const cur = roomCur(id);
        const tgt = roomTgt(id);
        const diff = tgt - cur;

        if (diff > 0) {
            rs.under += dt;
            rs.comp = clamp((Number(rs.comp) || 0) + SYSTEM.ROOM.COMP_INC, 0, SYSTEM.ROOM.MAX_COMP);
        } else {
            rs.under = 0;
            rs.comp = 0;
        }

        const isLiving = (id === "can_ting" || id === "ke_ting");
        let w = (isLiving ? 1.8 : 1.0) + Math.abs(diff) * 1.0;

        if ((rs.under || 0) >= SYSTEM.ROOM.MAX_UNDERHEAT_DURATION) w += 2.0;
        if (diff > 0) idx += w * diff;
        if (rs.comp > 0 && diff > 0) idx += rs.comp * 0.5;
    }

    return idx;
}

function powerTarget(demandIdx, comfort) {
    let P = SYSTEM.ROOM.KW_PER_INDEX * demandIdx;
    P += SYSTEM.COMFORT.KW_PER_C * Math.max(0, comfort.emax);

    if (comfort.upHoldS >= SYSTEM.COMFORT.UP_HOLD_S) {
        P += SYSTEM.COMFORT.STEP_KW;
        comfort.upHoldS = 0;
    }
    if (comfort.downHoldS >= SYSTEM.COMFORT.DOWN_HOLD_S) {
        P -= SYSTEM.COMFORT.STEP_KW;
        comfort.downHoldS = 0;
    }

    return clamp(P, 0, SYSTEM.HEAT.TARGET_MAX_KW);
}

function targetDeltaT(P_target, Q_m3h, emax) {
    let dtNeed;
    if (Q_m3h >= SYSTEM.HEAT.NOFLOW_M3H) dtNeed = P_target / (1.163 * Q_m3h);
    else dtNeed = 5 + 1.5 * Math.max(0, emax);

    return clamp(dtNeed, SYSTEM.HEAT.DT_MIN_C, SYSTEM.HEAT.DT_MAX_C);
}


// ========================= ç›®æ ‡æ¸©åº¦å€™é€‰ + å¹³æ»‘ =========================
function outdoorResetMin(outdoor) {
    return SYSTEM.MIN_TEMP + Math.max(0, (SYSTEM.OUTDOOR_RESET.REF_C - outdoor)) * SYSTEM.OUTDOOR_RESET.SLOPE;
}
function outdoorAdj(outdoor) {
    return (SYSTEM.OUTDOOR_ADJ.REF_C - outdoor) * SYSTEM.OUTDOOR_ADJ.SLOPE;
}
function sunAdj(lux) {
    const diff = lux - SYSTEM.SUN.REF_LUX;
    let adj = diff * SYSTEM.SUN.SLOPE;
    if (adj < SYSTEM.SUN.MAX) adj = SYSTEM.SUN.MAX;
    return adj;
}

function smoothTarget(state, candidate, now) {
    const last = Number(state.ctrl.lastTargetTs) || now;
    const dt = Math.max(1, (now - last) / 1000);
    state.ctrl.lastTargetTs = now;

    const prev = Number(state.ctrl.outputRaw) || SYSTEM.MIN_TEMP;

    const tau = SYSTEM.TARGET_TAU_S;
    const alpha = dt / (tau + dt);
    let sm = prev + alpha * (candidate - prev);

    const maxStep = SYSTEM.TARGET_MAX_STEP_PER_TICK_C * (dt / SYSTEM.TICK_S);
    sm = clamp(sm, prev - maxStep, prev + maxStep);

    state.ctrl.outputRaw = clamp(sm, SYSTEM.MIN_TEMP, SYSTEM.MAX_TEMP);
}


// ========================= æ°´ç®±æ¨¡å‹ï¼ˆå¯é€‰ï¼‰ =========================
function updateTankModel(state, now) {
    const interval = (now - (Number(state.ctrl.lastUpdate) || now)) / 1000;
    state.ctrl.lastUpdate = now;

    const mass = SYSTEM.TANK.BUFFER_L * SYSTEM.TANK.DENSITY;
    const heatDemandJ = updateHeatPower(state, interval);

    let dT = 0;
    if (state.sys.boilerMode === "buffer_heat") {
        dT = SYSTEM.TANK.HEAT_RATE * interval;
    } else {
        const naturalCooling = SYSTEM.TANK.LOSS_RATE * interval;
        const heatLossTemp = heatDemandJ / (mass * SYSTEM.TANK.SPECIFIC_HEAT * 1000);
        dT = -(naturalCooling + heatLossTemp);
    }

    state.thermal.watertank = parseFloat(clamp(state.thermal.watertank + dT, 10, 80).toFixed(1));
}


// ========================= é˜€é—¨æ§åˆ¶ V2 =========================
function computeValveSetPointDetailsV2(state, T_target, T_meas, T_return, T_tank) {
    const now = nowMs();

    const DEAD_BAND_C = 0.25;
    const RATIO_TAU_S = 30;

    const UNREACH_ENTER_C = 0.2;
    const UNREACH_EXIT_C  = 1.0;

    // â­é˜€é—¨åŠ¨ä½œé€Ÿåº¦ï¼ˆç‚¹/ç§’ï¼‰ï¼šè¶Šå°è¶Šæ…¢è¶Šç¨³
    const SP_SLEW_PER_SEC = 30;

    const SP_MIN_STEP = 8;

    const Kp_sp = 180;
    const Ki_sp = 6;
    const Kd_sp = 0;
    const INT_LIMIT = 20;

    if (!Number.isFinite(T_target) || !Number.isFinite(T_meas)) {
        return { set_point: 4095, ff_ratio: null, unreachable: false };
    }

    const lastTs = Number(state.valveLast.sp_last_ts) || now;
    const dt = Math.max(1, (now - lastTs) / 1000);
    state.valveLast.sp_last_ts = now;

    let unreachable = !!state.valveLast.unreachable;
    if (Number.isFinite(T_tank)) {
        if (!unreachable) {
            if (T_tank <= (T_target + UNREACH_ENTER_C)) unreachable = true;
        } else {
            if (T_tank >= (T_target + UNREACH_EXIT_C)) unreachable = false;
        }
    }
    state.valveLast.unreachable = unreachable;

    let ratio = 0.5;
    if (Number.isFinite(T_tank) && Number.isFinite(T_return)) {
        const denom = (T_tank - T_return);
        if (denom > 0.5) ratio = (T_target - T_return) / denom;
    }
    ratio = f01(ratio);

    let ratioEma = Number(state.valveLast.ratio_ema);
    if (!Number.isFinite(ratioEma)) ratioEma = ratio;
    const alphaR = dt / (RATIO_TAU_S + dt);
    ratioEma = f01(ratioEma + alphaR * (ratio - ratioEma));
    state.valveLast.ratio_ema = ratioEma;

    let sp_ff = 1 + Math.round(ratioEma * 4094);
    if (unreachable) sp_ff = 4095;

    let err = T_target - T_meas;
    if (Math.abs(err) < DEAD_BAND_C) err = 0;

    let integral = flow.get("integral") || 0;
    let prevErr  = flow.get("previous_error") || 0;

    if (err !== 0 && !unreachable) {
        integral += err * dt;
        integral = clamp(integral, -INT_LIMIT, INT_LIMIT);
    }

    flow.set("integral", integral);
    flow.set("previous_error", err);

    const derr = (err - prevErr) / dt;
    const sp_pid = (Kp_sp * err) + (Ki_sp * integral) + (Kd_sp * derr);

    let sp_target = Math.round(sp_ff + sp_pid);
    sp_target = clamp(sp_target, 1, 4095);

    let sp_prev = Number(state.valveLast.set_point);
    if (!Number.isFinite(sp_prev)) sp_prev = sp_target;

    const maxStep = Math.max(10, Math.round(SP_SLEW_PER_SEC * dt));
    let sp = sp_target;

    if (Math.abs(sp_target - sp_prev) > maxStep) {
        sp = sp_prev + maxStep * Math.sign(sp_target - sp_prev);
    }

    if (Math.abs(sp - sp_prev) < SP_MIN_STEP) sp = sp_prev;

    sp = clamp(sp, 1, 4095);
    state.valveLast.set_point = sp;

    return { set_point: sp, ff_ratio: ratioEma, unreachable };
}


// ========================= ç³»ç»Ÿå¥åº·ç›‘æ§ï¼ˆæŠ¥è­¦ï¼‰ =========================
function resetHealth() {
    context.set("fh_health", {
        enableSince: 0,
        lowFlowSince: 0,
        lastMixed: null,
        lastMixedChangeTs: 0,
        noRiseSince: 0,
        noRiseBase: null
    });
}

function checkHealthAndBuildAlarm(state, enabled, anyOpen, T_target_ctrl, valveSp) {
    if (!enabled || !anyOpen) {
        resetHealth();
        return null;
    }

    const now = nowMs();
    const h = context.get("fh_health") || {};
    if (!h.enableSince) h.enableSince = now;

    if ((now - h.enableSince) < HEALTH.STARTUP_GRACE_S * 1000) {
        const mixed = Number(state.sensors.mixedWaterTemp);
        if (Number.isFinite(mixed)) {
            if (h.lastMixed === null || Math.abs(mixed - h.lastMixed) >= 0.1) {
                h.lastMixed = mixed;
                h.lastMixedChangeTs = now;
            }
        }
        context.set("fh_health", h);
        return null;
    }

    const target = Number(T_target_ctrl);
    const mixed  = Number(state.sensors.mixedWaterTemp);
    const flowM3h = Number(state.sensors.waterFlowM3h) || 0;
    const tank = Number(state.thermal.watertank);

    const err = (Number.isFinite(target) && Number.isFinite(mixed)) ? (target - mixed) : 0;
    const demandStrong = (err >= HEALTH.DEMAND_ERR_C);

    if (Number.isFinite(mixed)) {
        if (h.lastMixed === null || Math.abs(mixed - h.lastMixed) >= 0.1) {
            h.lastMixed = mixed;
            h.lastMixedChangeTs = now;
        }
    }

    const lowFlowCond =
        demandStrong &&
        (Number(valveSp) >= HEALTH.VALVE_OPEN_SP) &&
        (flowM3h < HEALTH.FLOW_LOW_M3H);

    if (lowFlowCond) {
        if (!h.lowFlowSince) h.lowFlowSince = now;
        if ((now - h.lowFlowSince) >= HEALTH.FLOW0_HOLD_S * 1000) {
            context.set("fh_health", h);
            return buildAlarmMsg(
                "FLOW0",
                "åœ°æš–æµé‡å¼‚å¸¸",
                [
                    "ç°è±¡ï¼šåœ°æš–å·²å¼€å¯ä¸”éœ€è¦å‡æ¸©ï¼Œä½†æµé‡æŒç»­æ¥è¿‘ 0ï¼ˆä¸¥é‡ï¼‰",
                    `å½“å‰ï¼šç›®æ ‡${fmt1(target)}â„ƒ æ··æ°´${fmt1(mixed)}â„ƒ æ°´ç®±${fmt1(tank)}â„ƒ æµé‡${fmt1(flowM3h)}mÂ³/h é˜€é—¨${fmt0(valveSp)}`,
                    "å»ºè®®ï¼šæ£€æŸ¥å¾ªç¯æ³µæ˜¯å¦è½¬ã€è¿‡æ»¤å™¨æ˜¯å¦å µã€ç³»ç»Ÿæ˜¯å¦éœ€è¦æ’æ°”ã€é˜€é—¨æ˜¯å¦å¡ä½ã€æµé‡è®¡/é‡‡é›†æ˜¯å¦æ‰çº¿"
                ]
            );
        }
    } else {
        h.lowFlowSince = 0;
    }

    const staleMs = h.lastMixedChangeTs ? (now - h.lastMixedChangeTs) : 0;
    const mixStaleCond =
        demandStrong &&
        (flowM3h >= HEALTH.FLOW_OK_M3H) &&
        (staleMs >= HEALTH.MIX_STALE_HOLD_S * 1000);

    if (mixStaleCond) {
        context.set("fh_health", h);
        return buildAlarmMsg(
            "MIX_STALE",
            "æ··æ°´æ¸©åº¦é‡‡é›†å¼‚å¸¸",
            [
                "ç°è±¡ï¼šåœ°æš–è¿è¡Œä¸­ï¼Œæ··æ°´æ¸©åº¦é•¿æ—¶é—´ä¸å˜åŒ–ï¼ˆç–‘ä¼¼ä¼ æ„Ÿå™¨/é‡‡é›†å†»ç»“ï¼‰",
                `å½“å‰ï¼šç›®æ ‡${fmt1(target)}â„ƒ æ··æ°´${fmt1(mixed)}â„ƒ æµé‡${fmt1(flowM3h)}mÂ³/h`,
                "å»ºè®®ï¼šæ£€æŸ¥ mixed ä¼ æ„Ÿå™¨ã€Modbus/é‡‡é›†é“¾è·¯ã€ç›¸å…³èŠ‚ç‚¹æ˜¯å¦å¡ä½"
            ]
        );
    }

    const boilerMode = String(state.sys.boilerMode || "");
    const boilerBurning = !!state.sys.boilerBurning;

    const tankHotEnough =
        Number.isFinite(tank) && Number.isFinite(mixed) ? ((tank - mixed) >= HEALTH.TANK_HOT_MARGIN_C) : false;

    const heatSourceAvailable = (boilerMode === "buffer_heat") && boilerBurning && tankHotEnough;

    const noRiseCond =
        demandStrong &&
        Number.isFinite(mixed) &&
        (flowM3h >= HEALTH.FLOW_STRONG_M3H) &&
        heatSourceAvailable;

    if (noRiseCond) {
        if (!h.noRiseSince) {
            h.noRiseSince = now;
            h.noRiseBase = mixed;
        } else {
            const rise = mixed - Number(h.noRiseBase);
            if ((now - h.noRiseSince) >= HEALTH.NO_RISE_HOLD_S * 1000 &&
                rise < HEALTH.NO_RISE_DELTA_C) {

                context.set("fh_health", h);
                return buildAlarmMsg(
                    "NO_RISE",
                    "åœ°æš–å‡æ¸©å¼‚å¸¸",
                    [
                        "ç°è±¡ï¼šé”…ç‚‰åœ¨åœ°æš–åŠ çƒ­ä¸”æ°´ç®±æ¸©åº¦è¶³å¤Ÿï¼Œä½†æ··æ°´æ¸©åº¦é•¿æ—¶é—´å‡ ä¹ä¸å‡ï¼ˆä¸¥é‡ï¼‰",
                        `å½“å‰ï¼šç›®æ ‡${fmt1(target)}â„ƒ æ··æ°´${fmt1(mixed)}â„ƒ æ°´ç®±${fmt1(tank)}â„ƒ æµé‡${fmt1(flowM3h)}mÂ³/h`,
                        "å»ºè®®ï¼šæ£€æŸ¥æ¯”ä¾‹é˜€æ–¹å‘/åŠ¨ä½œæ˜¯å¦æ­£ç¡®ã€å›è·¯æ˜¯å¦æ—é€šçŸ­è·¯ã€é”…ç‚‰æ˜¯å¦çœŸæ­£ç»™æ°´ç®±åŠ çƒ­"
                    ]
                );
            }

            if (rise >= 0.3) {
                h.noRiseSince = 0;
                h.noRiseBase = null;
            }
        }
    } else {
        h.noRiseSince = 0;
        h.noRiseBase = null;
    }

    context.set("fh_health", h);
    return null;
}


// ========================= ä¸»é€»è¾‘å…¥å£ =========================
let msg_alarm = null;

try {
    const trigger = (typeof msg.payload === "string") ? msg.payload : "timer";
    const now = nowMs();

    const stored0 = flow.get(SYSTEM.STORAGE_KEY);
    const hasStored0 = (stored0 && typeof stored0 === "object");
    initRecoverCtrl(hasStored0);

    let state = mergeState(stored0);

    if (RECOVER_CONFIG.ENABLED) {
        const ready = (flow.get(RECOVER_CONFIG.READY_FLAG_KEY) === true);
        const applied = (context.get(RECOVER_CONFIG.APPLIED_KEY) === true);
        if (ready && !applied) {
            const s2 = flow.get(SYSTEM.STORAGE_KEY);
            if (s2 && typeof s2 === "object") {
                state = mergeState(s2);
                context.set(RECOVER_CONFIG.APPLIED_KEY, true);
            }
        }
    }

    const room = readRoomModes();
    const anyOpen = room.anyOpen;
    const allClosed = room.allClosed;

    updateSensors(state);

    const enforcePressed = isOnLike(flow.get(CONTROL_RULE.ENFORCE_FLOW_KEY));

    const prevEnabled = !!state.sys.enabled;
    const outdoor = Number(state.thermal.outdoor);

    let enabled = prevEnabled;

    if (anyOpen && outdoor < CONTROL_RULE.OUTDOOR_THRESHOLD_C) enabled = true;
    if (enforcePressed && anyOpen) enabled = true;
    if (allClosed && outdoor > CONTROL_RULE.OUTDOOR_THRESHOLD_C) enabled = false;

    state.sys.enabled = enabled;
    flow.set("floorheating_state", enabled);

    const out3 = output3Payload(trigger, state);
    const msg_out3 = out3.msg;
    const recoverTag = out3.tag;

    const msg_boiler = (trigger === "timer")
        ? { payload: (enabled ? "heat" : "off"), topic: "boiler/floorheating" }
        : null;

    let msg_enforce_reset = null;
    if (enforcePressed) {
        flow.set(CONTROL_RULE.ENFORCE_FLOW_KEY, "off");
        msg_enforce_reset = { payload: "off", topic: "enforce_reset" };
    }

    let msg_supply = null;
    if (trigger === "timer") msg_supply = buildSupplyMode(room, !enabled);

    // ====== OFF åˆ†æ”¯ ======
    if (!enabled) {
        resetHealth();
        state.valveLast.set_point = 4095;

        const msg_target_display = (trigger === "timer")
            ? { payload: String(Math.round(state.ctrl.outputRaw)), topic: "fh/target_display" }
            : null;

        const msg_valve = { payload: 4095, topic: "fh/valve_sp" };

        // âœ… status å¢åŠ é”…ç‚‰çŸ­æ ‡è®°
        const boilerTag = boilerTagFromState(state);
        const st = [`â›”OFF`, boilerTag, `ğŸ§©4095`];
        if (recoverTag) st.push(recoverTag);
        node.status({ fill: "grey", shape: "ring", text: st.join("|") });

        flow.set(SYSTEM.STORAGE_KEY, state);

        return [msg_target_display, msg_valve, msg_out3, msg_boiler, msg_enforce_reset, msg_supply, null];
    }

    // ===================== ON åˆ†æ”¯ï¼šç»¼åˆè®¡ç®— =====================
    const comfort = updateComfort(state, now, anyOpen, room);
    const dIdx = demandIndex(state, now, room);
    const P_target = powerTarget(dIdx, comfort);
    state.sensors.heatPowerTargetKw = P_target;

    const Q = Number(state.sensors.waterFlowM3h) || 0;
    const Tr = Number(state.sensors.returnWaterTemp);

    const dtNeed = targetDeltaT(P_target, Q, comfort.emax);
    state.sensors.targetDeltaT = dtNeed;

    let T_candidate = (Number.isFinite(Tr) ? Tr : 30) + dtNeed;

    T_candidate += outdoorAdj(outdoor);
    T_candidate += sunAdj(Number(state.sensors.sunlight) || 0);

    if (state.sys.boilerMode === "domestic") T_candidate -= 2;
    if (state.sys.boilerMode === "cooling")  T_candidate -= 1;

    T_candidate = Math.max(T_candidate, outdoorResetMin(outdoor));

    const tank = Number(state.thermal.watertank);
    if (Number.isFinite(tank) && tank > 5) T_candidate = Math.min(T_candidate, tank);

    T_candidate = clamp(T_candidate, SYSTEM.MIN_TEMP, SYSTEM.MAX_TEMP);
    state.sensors.targetTempCandidate = T_candidate;

    smoothTarget(state, T_candidate, now);
    updateTankModel(state, now);

    const T_target_display = Math.round(state.ctrl.outputRaw);
    const msg_target_display = { payload: String(T_target_display), topic: "fh/target_display" };

    const T_target_ctrl = Math.round(state.ctrl.outputRaw * 10) / 10;

    const T_feedback =
        (Number.isFinite(state.sensors.mixedWaterTemp) && state.sensors.mixedWaterTemp !== 0) ? state.sensors.mixedWaterTemp :
        (Number.isFinite(state.sensors.outputWaterTemp) && state.sensors.outputWaterTemp !== 0) ? state.sensors.outputWaterTemp :
        state.sensors.returnWaterTemp;

    const valve = computeValveSetPointDetailsV2(
        state,
        T_target_ctrl,
        T_feedback,
        Number(state.sensors.returnWaterTemp),
        Number(state.thermal.watertank)
    );

    const valveSp = Number(valve.set_point) || 4095;
    const msg_valve = { payload: valveSp, topic: "fh/valve_sp" };

    msg_alarm = checkHealthAndBuildAlarm(state, enabled, anyOpen, T_target_ctrl, valveSp);

    // âœ… status å¢åŠ é”…ç‚‰çŸ­æ ‡è®°
    const boilerTag = boilerTagFromState(state);

    const f = Number(state.sensors.waterFlowM3h) || 0;
    const Pema = Number(state.sensors.heatPowerEmaKw) || 0;
    const Pt = Number(state.sensors.heatPowerTargetKw) || 0;

    const st = [];
    if (recoverTag) st.push(recoverTag);
    st.push("ğŸ”¥ON");
    st.push(boilerTag); // âœ… æ–°å¢
    st.push(`ğŸ¯${T_target_ctrl.toFixed(1)}`);
    st.push(`ğŸŒ¡ï¸${Number(state.sensors.mixedWaterTemp).toFixed(1)}`);
    st.push(`ğŸ§©${valveSp}`);
    st.push(`ğŸ’§${f.toFixed(2)}`);
    st.push(`âš¡${Pema.toFixed(1)}/${Pt.toFixed(1)}`);

    // æŠ¥è­¦æ—¶ä¹Ÿå¸¦é”…ç‚‰æ ‡è®°ï¼ˆçŸ­ï¼‰
    if (msg_alarm) {
        node.status({ fill: "red", shape: "ring", text: `âš ï¸${msg_alarm.title}|${boilerTag}` });
    } else {
        node.status({ fill: "green", shape: "dot", text: st.join("|") });
    }

    flow.set(SYSTEM.STORAGE_KEY, state);

    return [msg_target_display, msg_valve, msg_out3, msg_boiler, msg_enforce_reset, msg_supply, msg_alarm];

} catch (e) {
    node.error(`[FATAL] ${e.message}`);

    const crash = buildAlarmMsg(
        "CODE_ERR",
        "åœ°æš–æ§åˆ¶ç¨‹åºå¼‚å¸¸",
        [
            "ç°è±¡ï¼šä¸»æ§ Function è¿è¡ŒæŠ¥é”™ï¼Œç³»ç»Ÿå¯èƒ½åœæ­¢æ­£å¸¸è°ƒèŠ‚",
            `é”™è¯¯ï¼š${e.message}`,
            "å»ºè®®ï¼šæŸ¥çœ‹ Node-RED æ—¥å¿—/è¿‘æœŸæ”¹åŠ¨/ä¼ æ„Ÿå™¨è¾“å…¥æ˜¯å¦å¼‚å¸¸"
        ]
    );

    node.status({ fill: "red", shape: "ring", text: "âŒERR|ğŸ§©4095" });

    return [
        { payload: String(SYSTEM.MIN_TEMP), topic: "fh/target_display" },
        { payload: 4095, topic: "fh/valve_sp" },
        null,
        { payload: "off", topic: "boiler/floorheating" },
        null,
        { topic: "climate/dinuan/gongshui/mode/set", payload: "off" },
        crash
    ];
}
